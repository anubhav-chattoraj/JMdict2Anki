import xml.etree.ElementTree as etree
import os.path
from pprint import pprint

# the JMDict XML file contains a well-commented DTD
# refer to it for details about the format

# temporary debug function, will remove later
def debug(entry):
  for keb in entry.findall('./k_ele/keb'): print('KEB: ' + keb.text)
  for reb in entry.findall('./r_ele/reb'): print('REB: ' + reb.text)

# generator function that returns only common words that aren't all-kana
# change this to change the words which get included in the deck
def get_common_words(root):
  def is_common(priority_list):
    # utility function
    # takes a list of nodes (generated by findall) and returns whether the corresponding element is common
    common_priorities = {'news1', 'ichi1', 'spec1', 'gai1'} # words with one of these priorities are considered 'common'
    priority_list = [node.text for node in priority_list]
    priority_set = common_priorities.intersection(set(priority_list))
    return bool(priority_set)

  for entry in root:
    k_ele = entry.findall('k_ele')
    if not k_ele: continue # ignore all-kana words

    common = is_common(entry.findall('./ke_ele/ke_pri') + entry.findall('./r_ele/re_pri'))
    if not common: continue # ignore uncommon words

    # remove uncommon variants/readings
    for k_ele in entry.findall('k_ele'):
      if not is_common(k_ele.findall('ke_pri')): entry.remove(k_ele)
    for r_ele in entry.findall('r_ele'):
      if not is_common(r_ele.findall('re_pri')): entry.remove(r_ele)

    yield entry

# takes an entry node and converts it into one or more csv lines
# change this if you want to change the structure of the Anki deck
def process_word(entry):
  # readings is { word: [reading] }
  readings = {keb.text : [] for keb in entry.findall('./k_ele/keb')}

  for r_ele in entry.findall('r_ele'):
    if r_ele.findall('re_nokanji'): continue # this r_ele is not a reading of the word

    reading = r_ele.find('reb').text
    words = [node.text for node in r_ele.findall('re_restr')]
    if words: # this reading is restricted to particular words in the entry
      for word in words:
        if word in readings: readings[word].append(reading)
    else: # reading applies to all words in the entry
      for word in readings: readings[word].append(reading)

  #debugging output
  pprint(readings)
  print("***")

path = os.path.join(os.path.expanduser('~'), 'JMdict_e') # change the path to point to the JMdict file
tree = etree.parse(path)
root = tree.getroot();
word_generator = get_common_words(root)

for word in word_generator:
  process_word(word)
